{
  "version": 3,
  "sources": ["../../../src/building/graph.ts"],
  "sourcesContent": ["/**\n * @license\n * Copyright 2022-2023 Project CHIP Authors\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport mapWorkspaces from \"@npmcli/map-workspaces\";\nimport colors from \"ansi-colors\";\nimport { Package } from \"../util/package.js\";\nimport { Progress } from \"../util/progress.js\";\nimport { Builder } from \"./builder.js\";\nimport { InternalBuildError } from \"./error.js\";\nimport { Project } from \"./project.js\";\n\n/**\n * Graph of dependencies for workspace packages.\n *\n * We use this information to determine which packages are \"dirty\" and need\n * rebuild.  In the future we can also use for parallel build, only tricky\n * part there is showing status.\n */\nexport class Graph {\n    protected constructor(readonly nodes: Graph.Node[]) {}\n\n    static async load(pkg = Package.workspace) {\n        const workspaces = await mapWorkspaces({ pkg: pkg.json, cwd: pkg.path });\n\n        const nodeMap = {} as Record<string, Graph.Node>;\n        const allDeps = {} as Record<string, string[]>;\n        for (const path of workspaces.values()) {\n            const pkg = new Package({ path: path });\n            allDeps[pkg.json.name] = pkg.dependencies;\n            nodeMap[pkg.json.name] = {\n                pkg,\n                dependencies: [],\n                buildTime: 0,\n                modifyTime: 0,\n\n                get dirty() {\n                    return (\n                        this.modifyTime > this.buildTime ||\n                        !!this.dependencies.find(d => d.dirty || d.buildTime > this.buildTime)\n                    );\n                },\n            };\n        }\n\n        for (const name in allDeps) {\n            for (const dep of allDeps[name]) {\n                const depNode = nodeMap[dep];\n\n                // Note -- allow nodes to reference themselves, seems to be\n                // necessary on tools for use of tsc\n                if (depNode && depNode !== nodeMap[name]) {\n                    nodeMap[name].dependencies.push(depNode);\n                }\n            }\n        }\n\n        const graph = new Graph(Object.values(nodeMap));\n\n        await Promise.all(\n            graph.nodes.map(async node => {\n                node.buildTime = await node.pkg.lastModified(\"build/timestamp\");\n\n                node.modifyTime = await node.pkg.lastModified(\"package-lock.json\", \"src\", \"test\");\n\n                return node;\n            }),\n        );\n\n        const stack = Array<Graph.Node>();\n        function findCircular(node: Graph.Node) {\n            if (stack.indexOf(node) !== -1) {\n                stack.push(node);\n                throw new InternalBuildError(`Circular dependency: ${stack.map(formatDep).join(\" \u25B8 \")}`);\n            }\n            stack.push(node);\n            for (const dep of node.dependencies) {\n                findCircular(dep);\n            }\n            stack.pop();\n        }\n        for (const node of graph.nodes) {\n            findCircular(node);\n        }\n\n        return graph;\n    }\n\n    // TODO - parallelization will be trivial except need to update Progress\n    // to support display of multiple simultaneous tasks\n    async build(builder: Builder) {\n        const toBuild = new Set(this.nodes);\n\n        while (toBuild.size) {\n            let node;\n\n            nodes: for (node of toBuild) {\n                for (const dep of node.dependencies) {\n                    if (dep.dirty) {\n                        continue nodes;\n                    }\n                }\n                break;\n            }\n\n            if (!node) {\n                throw new Error(\"Internal logic error: No unbuilt project has fully built dependencies\");\n            }\n\n            if (node.dirty || builder.unconditional) {\n                await builder.build(new Project(node.pkg));\n                node.buildTime = Date.now();\n            } else {\n                new Progress().skip(\"Up to date\", node.pkg);\n            }\n\n            toBuild.delete(node);\n        }\n    }\n\n    display() {\n        for (const node of this.nodes) {\n            const progress = node.pkg.start(\"Node\");\n            progress.info(\"path\", node.pkg.path);\n            progress.info(\"modified\", formatTime(node.modifyTime));\n            progress.info(\"built\", formatTime(node.buildTime));\n            progress.info(\"dirty\", node.dirty ? colors.dim.red(\"yes\") : colors.dim.green(\"no\"));\n            progress.info(\"dependencies\", node.dependencies.map(formatDep).join(\", \"));\n            progress.shutdown();\n        }\n    }\n}\n\nexport namespace Graph {\n    export interface Node {\n        pkg: Package;\n        dependencies: Node[];\n        buildTime: number;\n        modifyTime: number;\n        dirty: boolean;\n    }\n}\n\nfunction formatTime(time: number) {\n    if (!time) {\n        return colors.dim.red(\"never\");\n    }\n    return new Date(time - new Date().getTimezoneOffset()).toISOString().split(\".\")[0].replace(\"T\", \" \");\n}\n\nfunction formatDep(node: Graph.Node) {\n    return node.pkg.name.replace(/^@project-chip\\//, \"\");\n}\n"],
  "mappings": "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",
  "names": ["mapWorkspaces", "pkg", "colors"]
}
