{
  "version": 3,
  "sources": ["../../../../src/testing/mocks/time.ts"],
  "sourcesContent": ["/**\n * @license\n * Copyright 2022-2023 Project CHIP Authors\n * SPDX-License-Identifier: Apache-2.0\n */\n\ntype TimerCallback = () => any;\n\n// Must match matter.js Timer interface\nclass MockTimer {\n    isRunning = false;\n    private readonly callback: TimerCallback;\n\n    constructor(\n        private readonly mockTime: MockTime,\n        private readonly durationMs: number,\n        callback: TimerCallback,\n    ) {\n        if (this instanceof MockInterval) {\n            this.callback = callback;\n        } else {\n            this.callback = () => {\n                this.isRunning = false;\n                callback();\n            };\n        }\n    }\n\n    start() {\n        this.mockTime.callbackAtTime(this.mockTime.nowMs() + this.durationMs, this.callback);\n        this.isRunning = true;\n        return this;\n    }\n\n    stop() {\n        this.mockTime.removeCallback(this.callback);\n        this.isRunning = false;\n        return this;\n    }\n}\n\nclass MockInterval extends MockTimer {\n    constructor(mockTime: MockTime, durationMs: number, callback: TimerCallback) {\n        const intervalCallback = async () => {\n            mockTime.callbackAtTime(mockTime.nowMs() + durationMs, intervalCallback);\n            await callback();\n        };\n        super(mockTime, durationMs, intervalCallback);\n    }\n}\n\ntype InterceptResult<T> =\n    T extends Promise<T>\n        ? { resolve: Awaited<T>; reject?: undefined } | { resolve?: undefined; reject: {} }\n        : { resolve: T; reject?: undefined } | { resolve?: void; reject: {} };\n\nfunction isAsync(fn: (...args: any) => any): fn is (...args: any) => Promise<any> {\n    return fn.constructor.name === \"AsyncFunction\";\n}\n\n// Must match matter.js Time interface\nexport class MockTime {\n    private callbacks = new Array<{ atMs: number; callback: TimerCallback }>();\n    private timeMs: number;\n\n    constructor(private startTimeMs: number) {\n        this.timeMs = this.startTimeMs;\n    }\n\n    reset(time = this.startTimeMs) {\n        this.callbacks = [];\n        this.timeMs = time;\n    }\n\n    now(): Date {\n        return new Date(this.timeMs);\n    }\n\n    nowMs(): number {\n        return this.timeMs;\n    }\n\n    getTimer(durationMs: number, callback: TimerCallback): MockTimer {\n        return new MockTimer(this, durationMs, callback);\n    }\n\n    getPeriodicTimer(intervalMs: number, callback: TimerCallback): MockTimer {\n        return new MockInterval(this, intervalMs, callback);\n    }\n\n    /**\n     * Move time forward.  Runs tasks scheduled during this interval.\n     */\n    async advance(ms: number) {\n        const newTimeMs = this.timeMs + ms;\n\n        while (true) {\n            if (this.callbacks.length === 0) break;\n            const { atMs, callback } = this.callbacks[0];\n            if (atMs > newTimeMs) break;\n            this.callbacks.shift();\n            this.timeMs = atMs;\n            await callback();\n        }\n\n        this.timeMs = newTimeMs;\n    }\n\n    /**\n     * Yield to scheduled microtasks.  This means that all code paths waiting\n     * on resolved promises (including await) will proceed before this method\n     * returns.\n     */\n    async yield() {\n        await Promise.resolve();\n    }\n\n    /**\n     * Due to its implementation, an older version of yield() would actually\n     * yield to microtasks three times.  Our tests then depended on this\n     * functionality -- one yield could trigger up to three nested awaits.\n     *\n     * To make this clear, the version of yield() that emulates old behavior\n     * is called \"yield3\".\n     */\n    async yield3() {\n        await Promise.resolve();\n        await Promise.resolve();\n        await Promise.resolve();\n    }\n\n    /**\n     * Hook a method and invoke a callback just before the method completes.\n     * Unhooks after completion.\n     *\n     * Handles both synchronous and asynchronous methods.  The interceptor\n     * should match the async-ness of the intercepted method.\n     *\n     * The interceptor can optionally access and/or replace the resolve/reject\n     * value.\n     */\n    interceptOnce<NameT extends string, ReturnT, ObjT extends { [N in NameT]: (...args: any) => ReturnT }>(\n        obj: ObjT,\n        method: NameT,\n        interceptor: (\n            result: InterceptResult<ReturnT>,\n        ) => void | InterceptResult<ReturnT> | Promise<void> | Promise<InterceptResult<ReturnT>>,\n    ) {\n        const original = obj[method];\n        if (!original) {\n            throw new Error(`Interception method ${method} is not present`);\n        }\n        let result: InterceptResult<ReturnT>;\n        if (isAsync(interceptor)) {\n            obj[method] = async function (this: any, ...args: any): Promise<any> {\n                try {\n                    // eslint-disable-next-line @typescript-eslint/await-thenable\n                    const resolve = await original.apply(this, args);\n                    result = { resolve } as any;\n                } catch (reject) {\n                    result = { reject } as any;\n                } finally {\n                    obj[method] = original;\n                }\n                result = (await interceptor(result)) ?? result;\n                if (result.reject) {\n                    throw result.reject;\n                }\n                return result.resolve;\n            } as any;\n        } else {\n            obj[method] = function (this: any, ...args: any): any {\n                try {\n                    const resolve = original.apply(this, args);\n                    result = { resolve } as any;\n                } catch (reject) {\n                    result = { reject } as any;\n                } finally {\n                    obj[method] = original;\n                }\n                result = (interceptor(result) as any) ?? result;\n                if (result.reject) {\n                    throw result.reject;\n                }\n                return result.resolve;\n            } as any;\n        }\n    }\n\n    callbackAtTime(atMs: number, callback: TimerCallback) {\n        this.callbacks.push({ atMs, callback });\n        this.callbacks.sort(({ atMs: atMsA }, { atMs: atMsB }) => atMsA - atMsB);\n    }\n\n    removeCallback(callbackToRemove: TimerCallback) {\n        const index = this.callbacks.findIndex(({ callback }) => callbackToRemove === callback);\n        if (index === -1) return;\n        this.callbacks.splice(index, 1);\n    }\n}\n\nexport const TheMockTime = new MockTime(0);\nexport function timeSetup(Time: { get: () => MockTime }) {\n    Time.get = () => TheMockTime;\n}\n"],
  "mappings": "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",
  "names": []
}
