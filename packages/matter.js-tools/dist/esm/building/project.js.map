{
  "version": 3,
  "sources": ["../../../src/building/project.ts"],
  "sourcesContent": ["/**\n * @license\n * Copyright 2022-2023 Project CHIP Authors\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { build as esbuild, Format } from \"esbuild\";\nimport { cp, mkdir, readFile, rm, stat, symlink, writeFile } from \"fs/promises\";\nimport { glob } from \"glob\";\nimport { platform } from \"os\";\nimport { ignoreError } from \"../util/errors.js\";\nimport { Package } from \"../util/package.js\";\nimport { Typescript } from \"./typescript.js\";\n\nexport class Project {\n    pkg: Package;\n\n    constructor(source: Package | string = \".\") {\n        if (typeof source === \"string\") {\n            this.pkg = new Package({ path: source });\n        } else {\n            this.pkg = source;\n        }\n\n        if (!this.pkg.src) {\n            throw new Error(`Found package ${this.pkg.json.name} but no src directory is present`);\n        }\n    }\n\n    async buildSource(format: Format) {\n        await this.build(format, \"src\", `dist/${format}`);\n        await this.specifyFormat(\"dist\", format);\n    }\n\n    async buildTests(format: Format) {\n        await ignoreError(\"ENOENT\", async () => {\n            if ((await stat(this.pkg.resolve(\"test\"))).isDirectory()) {\n                await this.build(format, \"test\", `build/${format}/test`);\n            }\n        });\n\n        const src = `dist/${format}`;\n        const dest = `build/${format}/src`;\n\n        try {\n            await ignoreError(\"EEXIST\", async () => await symlink(this.pkg.resolve(src), this.pkg.resolve(dest)));\n        } catch (e) {\n            if ((e as any).code === \"EPERM\" && platform() === \"win32\") {\n                // If developer mode is not enabled, we can't create a symlink\n                // on Windows.  Copy instead\n                await cp(this.pkg.resolve(src), this.pkg.resolve(dest), {\n                    recursive: true,\n                    force: true,\n                });\n            } else {\n                throw e;\n            }\n        }\n        await this.specifyFormat(\"build\", format);\n    }\n\n    async clean() {\n        for (const dir of [\"build\", \"dist\"]) {\n            await rm(this.pkg.resolve(dir), { recursive: true, force: true });\n        }\n    }\n\n    async buildDeclarations() {\n        Typescript.emitDeclarations(this.pkg);\n    }\n\n    async validateTypes() {\n        Typescript.validateTypes(this.pkg);\n    }\n\n    async installDeclarationFormat(format: Format) {\n        const srcMaps = Array<[string, string]>();\n\n        await cp(this.pkg.resolve(\"build/types/src\"), this.pkg.resolve(`dist/${format}`), {\n            recursive: true,\n            force: true,\n\n            filter: (source, dest) => {\n                if (source.endsWith(\".d.ts.map\")) {\n                    srcMaps.push([source, dest]);\n                    return false;\n                }\n                return true;\n            },\n        });\n\n        // If you specify --sourceRoot, tsc just sticks whatever the string is\n        // directly into the file.  Not very useful unless you have no\n        // hierarchy or use absolute paths...\n        //\n        // We distribute types for src one level higher than we generate them\n        // (dist/esm vs build/types/src) so the paths end up incorrect.\n        //\n        // So...  Rewrite the paths in all source maps under src/.  Do this\n        // directly on buffer for marginal performance win.\n        for (const [source, dest] of srcMaps) {\n            // Load map as binary\n            const map = await readFile(source);\n\n            // Find key text\n            let pos = map.indexOf('\"sources\":[\"../');\n            if (pos === -1) {\n                throw new Error(\n                    `Could not find sources position in declaration map ${source}, format may have changed`,\n                );\n            }\n\n            // move to ../\n            pos += 12;\n\n            // Shift everything left by three\n            map.copyWithin(pos, pos + 3);\n\n            // Write to new location\n            await writeFile(dest, map.subarray(0, map.length - 3));\n        }\n    }\n\n    async installDeclarations() {\n        await mkdir(this.pkg.resolve(\"dist\"), { recursive: true });\n        if (this.pkg.esm) {\n            await this.installDeclarationFormat(\"esm\");\n        }\n        if (this.pkg.cjs) {\n            await this.installDeclarationFormat(\"cjs\");\n        }\n    }\n\n    async recordBuildTime() {\n        await mkdir(this.pkg.resolve(\"build\"), { recursive: true });\n        await writeFile(this.pkg.resolve(\"build/timestamp\"), \"\");\n    }\n\n    private async build(format: Format, indir: string, outdir: string) {\n        const config = (await ignoreError(\n            \"ERR_MODULE_NOT_FOUND\",\n            () => import(`file://${this.pkg.path}/build.config.js`),\n        )) as Project.Config;\n\n        await config?.before?.(this, format);\n\n        const entryPoints = await this.targets(indir, outdir, \"ts\", \"js\");\n        for (const entry of entryPoints) {\n            entry.out = entry.out.replace(/\\.[jt]s$/, \"\");\n        }\n\n        await esbuild({\n            entryPoints,\n            outdir: this.pkg.path,\n            format,\n            sourcemap: true,\n            absWorkingDir: this.pkg.path,\n        });\n\n        for (const entry of await this.targets(indir, outdir, \"cjs\", \"mjs\", \"d.cts\", \"d.mts\")) {\n            await cp(entry.in, entry.out);\n        }\n\n        await config?.after?.(this, format);\n    }\n\n    private async specifyFormat(dir: string, format: Format) {\n        if (format === \"cjs\") {\n            await writeFile(this.pkg.resolve(`${dir}/${format}/package.json`), '{ \"type\": \"commonjs\" }');\n        }\n    }\n\n    private async targets(indir: string, outdir: string, ...extensions: string[]) {\n        indir = this.pkg.resolve(indir).replace(/\\\\/g, \"/\");\n        outdir = this.pkg.resolve(outdir).replace(/\\\\/g, \"/\");\n\n        return (await glob(extensions.map(ext => `${indir}/**/*.${ext}`))).map(file => ({\n            in: file,\n            out: `${outdir}/${file.slice(indir.length + 1)}`,\n        }));\n    }\n}\n\nexport namespace Project {\n    export interface Config {\n        before?: (project: Project, format: Format) => Promise<void>;\n        after?: (project: Project, format: Format) => Promise<void>;\n    }\n}\n"],
  "mappings": "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",
  "names": []
}
